import ifcopenshell as ifc
import ifcopenshell.util.classification
import ifcopenshell.util.selector

#this func. finds all the IFC types in the model
#the file's path needs to replace the 'ifc_path'
ifc_path = '/Users/alisatellefsen/Library/CloudStorage/OneDrive-DanmarksTekniskeUniversitet/DTU/Kandidat/2. Sem/41934 Advanced BIM/openBIManalyst_GRP2/25-16-D-ARCH.ifc'

#this fun. finds all the unique ifc types
def unique_ifc_types(ifc_path):
    model = ifc.open(ifc_path)
    ifc_type_list = {"typer"}
    #loop over all the elements to find all the unique ifc types
    for element in model:
        ifc_type_list.add(element.is_a())
    #printing the types in the terminal 
    print(f"Unique IFC types in the model: ")
    print(*ifc_type_list, sep="\n")
    return ifc_type_list

#this func. checks for classifications
def count_classification_ref(ifc_path, ifc_type_list):
    model = ifc.open(ifc_path)
    count_with = 0
    count_without = 0
    #here you need to write which ifc_type you want to be checked in the terminal
    ifc_type = ""
    while ifc_type not in ifc_type_list:
        ifc_type = input("What type do you want classifications from? (Maybe it didn't exist)\n")

    element_list = model.by_type(ifc_type)
    #only then will it find classifications
    for element in element_list:
        references = ifcopenshell.util.classification.get_references(element)
        if references:   
            for reference in references:
                system = ifcopenshell.util.classification.get_classification(reference)
                if system:
                    count_with += 1
                else:
                    count_without += 1
        else:
            count_without += 1
    e_with = f'Amount of elements with classification: {count_with}'
    e_without = f'Amount of elements without classification: {count_without}'
    return e_with, e_without


#this func. looks for desks in the model, but with a location filter
def look_for_desks(ifc_path):
    model = ifc.open(ifc_path)
    lv_1_desks = ifcopenshell.util.selector.filter_elements(model, 'Name=/.*Desk.*/, location="Level 1"')
    lv_2_desks = ifcopenshell.util.selector.filter_elements(model, 'Name=/.*Desk.*/, location="Level 2"')
    lv_3_desks = ifcopenshell.util.selector.filter_elements(model, 'Name=/.*Desk.*/, location="Level 3"')
    lv_4_desks = ifcopenshell.util.selector.filter_elements(model, 'Name=/.*Desk.*/, location="Level 4"')
    #check what we have filtered 
    #print(*lv_1_desks, sep="\n")
    desk_lvs = f"No. desks lv_1 - lv_4: {len(lv_1_desks), len(lv_2_desks), len(lv_3_desks), len(lv_4_desks)}"
    return desk_lvs


#this func. looks for bicycles in the model, even though they fall outside of the location filter
def look_for_bicycles(ifc_path):
    model = ifc.open(ifc_path)
    storeys = model.by_type("IfcBuildingStorey")
    list_lv_bicycle = []
    for s in storeys:
        contained = []
        for rel in getattr(s, "ContainsElements", []):
            for i in rel.RelatedElements:
                if "enkelzijdig" in i.Name or "Enkelzijdig" in i.Name:
                    contained.append(i)
            #contained.extend(rel.RelatedElements or [])
        print(s.Name, "→", len(contained), "elements")
        list_lv_bicycle.append(f"{s.Name} → {len(contained)} elements")
    return list_lv_bicycle


#run the funcs. 
ifc_type_list = unique_ifc_types(ifc_path)
ifc_class_list =count_classification_ref(ifc_path, ifc_type_list)
ifc_find_desks = look_for_desks(ifc_path)
ifc_find_bicycles = look_for_bicycles(ifc_path)

with open("A1_analyst_checks_GRP2.txt", "w") as f:
  f.write("Here are the elements w/w.o. classifications\n")
  f.write(ifc_class_list[0])
  f.write("\n")
  f.write(ifc_class_list[1])
  f.write("\n")
  f.write("Here are no of desks per storey")
  f.write("\n")
  f.write(ifc_find_desks)
  f.write("\n")
  f.write("Here are the bicycle stands per storey. There are 6 stands per unit.")
  f.write("\n")
  for i in ifc_find_bicycles:
    f.write(i)
    f.write("\n")
